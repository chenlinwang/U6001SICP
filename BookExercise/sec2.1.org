* Exercise 2.1

Define a better version of make-rat that handles both positive and negative arguments. Make-rat should normalize the sign so that if the rational number is positive, both the numerator and denominator are positive, and if the rational number is negative, only the numerator is negative.
** Answer
Just make sure that =make-rat= check the positive-negative symbols.

* Exercise 2.2

Consider the problem of representing line segments in a plane. Each segment is represented as a pair of points: a starting point and an ending point. Define a constructor make-segment and selectors start-segment and end-segment that define the representation of segments in terms of points. Furthermore, a point can be represented as a pair of numbers: the x coordinate and the y coordinate. Accordingly, specify a constructor make-point and selectors x-point and y-point that define this representation. Finally, using your selectors and constructors, define a procedure midpoint-segment that takes a line segment as argument and returns its midpoint (the point whose coordinates are the average of the coordinates of the endpoints). To try your procedures, you'll need a way to print points:
#+BEGIN_SRC scheme
(define (print-point p)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")")
  (newline))
#+END_SRC
** Answer
Go with points then line segments, And for the segment, I denote that the left point goes first. If it is a vertical line, then the bottom point goes first. Thus the line segment has unique representation.

#+BEGIN_EXAMPLE

make-point x-point y-point

----------------------------------------

point-add point-scalar-times

----------------------------------------

make-segment start-segment end-segment

----------------------------------------

midpoint-segment

#+END_EXAMPLE
* Exercise 2.3

 Implement a representation for rectangles in a plane. (Hint: You may want to make use of exercise 2.2.) In terms of your constructors and selectors, create procedures that compute the perimeter and the area of a given rectangle. Now implement a different representation for rectangles. Can you design your system with suitable abstraction barriers, so that the same perimeter and area procedures will work using either representation?

** Answer
*** Analysis
It is tricky to construct such thing as we do not know what the data are for. There are many ways to construct a data type for the rectangle. The one thing that every method should pay attention is that the representaion should have uniqueness which means a rectange will only has one representation and vice versa.

So naturally to adapt the line segement we have above. We represent the rectange with two line segements. And counting clockwise starting from 12 o'clock, the first segment go first and second second.

*Thus we should check three things:*
**** Whether the line segment share a point.
Check the 4 possible combinations.

**** Whether the lines crossed at an angle of 90 degree.
This is easily checked using the forumal: k1 * k2 = -1.

**** How to get the two sides we want.
This part is tricky. There are three cases:
***** They have the same starting point
It is great. It is exactly what we want. So we just have to find out which is upper. It is decided by the y axis. Just compared them.
***** They have the same ending point
This is really opposite to the goal. However, basic algebra told us to move the line using the vector addition.So move the both line back, and we are fine.
***** One is start, one is end
So move the one which start from the end of the other back.

*** Implement

**** Points
We need to have point to tell us:
1. whether the two points are the same point.

**** Line
We need the segments to tell us:

1. whether they are met.
2. whether they are perpendicular to each other.
3. which points are they meet.
4. How to decide which segment is upper.
5. how to move the segment alone the other.

For the last one, I think it is useful that we implement the /vector/, it is basically share the properties of point, but could be used to move and calculate the perpendicularity easily.

**** Vector
***** Construct
It is composed by a line segment.

***** Selector
****** Length
Calculate the length of the vector

****** End point
Return the end point of the vector

***** Operator
****** Point Product
To see whether two vectors are perpendicular

****** Scalar Product
To multiply a scalar

****** Move alone
Acting on line segment, to move the line alone the vector.


*** Abstraction Barriers
#+BEGIN_EXAMPLE

points and line segments
----------------------------------------

vectors

----------------------------------------

rectangle
#+END_EXAMPLE
* Exercise 2.4

Here is an alternative procedural representation of pairs. For this representation, verify that (car (cons x y)) yields x for any objects x and y.

#+BEGIN_SRC scheme
(define (cons x y)
  (lambda (m) (m x y)))
(define (car z)
  (z (lambda (p q) p)))
#+END_SRC

What is the version of =cdr= ?
** Answer
I will write down how =scheme= evaluate the combination =(car (cons 1 2))= in this way:

#+BEGIN_SRC scheme
(car (cons 1 2))

(car (lambda (m) (m 1 2)))

((lambda (m) (m 1 2)) (lambda (p q) (p)))

((lambda (p q) (p)) 1 2)

(1)

1
#+END_SRC

It is fun! The =cdr= should be:
#+BEGIN_SRC scheme
(define (cdr z)
  (z (lambda (p q) q)))
#+END_SRC

* Exercise 2.5
Show that we can represent pairs of nonnegative integers using only numbers and arithmetic operations if we represent the pair a and b as the integer that is the product 2a 3b. Give the corresponding definitions of the procedures cons, car, and cdr.
** Answer
That is rather easy. Just write a exponient function and divide function.
#+BEGIN_SRC scheme
;;test for even odd property
 (define (even? num)
   (= (remainder num 2) 0))

 ;;fast-exp
 (define (fast-exp bas exp)
   (define (fei l b e)
     (cond ((= e 1) (* l b))
           ((even? e) (fei l (* b b) (/ e 2)))
           (else (fei (* l b) b (- e 1)))))
   (fei 1 bas exp))

 ;;new cons 2
 (define (new-cons2 a b)
   (* (fast-exp 2 a)
      (fast-exp 3 b)))

 ;;has exponient
 (define (has-exp num bas)
   (define (left? x)
     (= (remainder x bas) 0))

   (define (hei num exp)
     (if (left? num)
         (hei (/ num bas) (+ exp 1))
         exp))
  (hei num 0))

;;new car 2
(define (new-car2 num)
  (has-exp num 2))

;;new cdr 2
(define (new-cdr2 num)
  (has-exp num 3))
#+END_SRC
* Exercise 2.6

In case representing pairs as procedures wasn't mind-boggling enough, consider that, in a language that can manipulate procedures, we can get by without numbers (at least insofar as nonnegative integers are concerned) by implementing 0 and the operation of adding 1 as:

#+BEGIN_SRC scheme
(define zero (lambda (f) (lambda (x) x)))

(define (add-1 n)
    (lambda (f) (lambda (x) (f ((n f) x)))))
#+END_SRC

This representation is known as Church numerals, after its inventor, Alonzo Church, the logician who invented the lambda calculus.
Define one and two directly (not in terms of zero and add-1). (Hint: Use substitution to evaluate (add-1 zero)). Give a direct definition of the addition procedure + (not in terms of repeated application of add-1).
** Answer
The /Church numeral/ basically use the times a procedure =f= that applied to =x= to represent the natural number. So =zero= means apply zero time of =f= to =x=. =one= means apply one time of =f= to x and so on.

#+BEGIN_SRC scheme
;The one is:
(define one (lambda (f) (lambda (x) (f x))))

;The plus is:
(define (church-add x y)
  (lambda (f) ((x f) ((y f) x))))
#+END_SRC
