* Ex 1.9
** First One
#+BEGIN_SRC Scheme
(+ 4 5)

(inc (+ (dec 4) 5))

(inc (+ 3 5))

(inc (inc (+ (dec 3) 5)))

(inc (inc (+ 2 5)))

(inc (inc (inc (+ (dec 2) 5))))

(inc (inc (inc (+ 1 5))))

(inc (inc (inc (inc (+ (dec 1) 5)))))

(inc (inc (inc (inc (+ 0 5)))))

(inc (inc (inc (inc 5))))

...

9
#+END_SRC

It is a recursive, because it keep a record of the previous operators.

** Second
#+BEGIN_SRC scheme
(+ 4 5)

(+ (dec 4) (inc 5))

(+ 3 6)

(+ (dec 3) (inc 6))

(+ 2 7)

(+ (dec 2) (inc 7))

(+ 1 8)

(+ (dec 1) (inc 8))

(+ 0 9)

9
#+END_SRC

It is iterative.

* Ex 1.10
** Answer
#+BEGIN_EXAMPLE
(A 1 10) > 1024

(A 2 4) > 65536

(A 3 3) > 65536
#+END_EXAMPLE
** Calculation
#+BEGIN_SRC latex
$$ f(n) = 2 n $$

$$ g(n) = 2^n $$

$$ h(n) = 2^{2^{2 \dots ^2}} (n times 2)$$
#+END_SRC
* Ex 1.11
#+BEGIN_SRC scheme
(define (f-r n)
  (if (< n 3)
      n
      (+ (f-r (- n 1)) (f-r (- n 2)) (f-r (- n 3)))))

(define (f-i n)
  (define (f-iter f m l n)
    (if (= n 0)
        f
        (f-iter m l (+ f m l) (- n 1))))
  (f-iter 0 1 2 n))
#+END_SRC

* Ex 1.12

#+BEGIN_SRC scheme
(define (p-r n i)
  (if (or (= i 1) (= i n))
      1
      (+ (p-r (- n 1) (- i 1)) (p-r (- n 1) i))))
#+END_SRC

* Ex 1.13
[[file:sec1.2-ex1.13.png]]
* Ex 1.14
for n money unit with m kinds of moneys, it is the theta of n^m.
* Ex 1.15
** a
5 times

for number =x= , =times = min{ m | x/3^m < 0.1}=

** b
It is a recursive process, so time is the same as space. It is theta of =log a=.
* Ex 1.16
Use the trick of adding a number to denote odd remainders.
So =a= will multiply =b= everytime =n= is odd and =b= will be squared everytime =n= is even.

*This is very easily mistaken with =a= muliply of =root= everytime =n= is odd.
#+BEGIN_SRC scheme; iterative version of the fast exponent
(define root 2)

(define (ex-f-i n)
  (define (square n) (* n n))
  ;define a test for even
  (define (even? n)
    (= (remainder n 2) 0))
  ;real process
  (define (ex-f-iter a b n)
    (cond ((= n 0) 0)
          ((= n 1) (* a b))
          ((even? n)
           (ex-f-iter a (square b) (/ n 2)))
          (else
           (ex-f-iter (* a b) b (- n 1)))))
  (ex-f-iter 1 root n))
#+END_SRC
* Ex 1.17 1.18
Similarly
#+BEGIN_SRC scheme

;;build the default operators
;double the number
(define (double n)
  (* n 2))
;halve
(define (halve n)
  (/ n 2))
;root
(define root 2)

;;So do it-again
;test for even
(define (even? n)
  (= (remainder n 2) 0))

;recursive
(define (mul-f-r n)
  (cond ((= 0 n) 0)
        ((even? n)
         (double (mul-f-r (halve n))))
        (else
         (+ root (mul-f-r (- n 1))))))

;iterative
(define (mul-f-i n)
  (define (mul-f-iter a b n)
    (cond ((= n 0) 0)
          ((= n 1) (+ a b))
          ((even? n) (mul-f-iter a (double b) (halve n)))
          (else
           (mul-f-iter (+ a b) b (- n 1)))))
  (mul-f-iter 0 root n))
#+END_SRC

* Ex 1.19
There is really some confusion in the termination condition. So I start the sequence with first and second and third element as no.1 2 3.

In that case, we have:
#+BEGIN_SRC scheme
;square
(define (square x) (* x x))
;Define the calculation for p and q
(define (cal-p p q) (+ (square p) (square q)))
(define (cal-q p q) (+ (* 2 p q) (square q)))
;Define how to apply tranformation T
(define (cal-tl p q l f) (+ (* l (+ p q)) (* f q)))
(define (cal-tf p q l f) (+ (* l q) (* f p)))

;iterative
(define (fib-f-i n)
  (define (fi p q l f n)
    (cond ((= 0 n) f)
          ((even? n)
           (fi (cal-p p q) (cal-q p q) l f (/ n 2)))
          (else
           (fi p q (cal-tl p q l f) (cal-tf p q l f) (- n 1)))))
  (fi 0 1 1 0 (- n 1)))
#+END_SRC
* Ex 1.20
** Normal Order
As we evaluate, it goes:
#+BEGIN_SRC scheme
(gcd 206 40)

(if (= 40 0)
    206
    (gcd 40 (remainder 206 40)))

(gcd 40 (remainder 206 40))

(if (= (remainder 206 40) 0)
    40
    (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))

(if (= 6 0)
    40
    (gcd (remainder 206 40) (remainder 40 (remainder 206 40))))

(gcd (remainder 206 40) (remainder 40 (remainder 206 40)))
...
#+END_SRC

We could deduce a sequence {a_n}, for the number of remainders in the latter position of the two number for each appearance of =gcd=. So:

*a_n = a_{n-1} + a_{n-2} + 1*

With a_0 = 0 , a_1 = 1, so the =gcd(206,40)= involves 5 appears:
#+BEGIN_EXAMPLE
a_0 = 0
a_1 = 1
a_2 = 2
a_3 = 4
a_4 = 7
#+END_EXAMPLE

The answer is the sum of them, that is 14.

** Applicative Order
#+BEGIN_SRC scheme
(gcd 206 40)

(if (= 40 0)
    206
    (gcd 40 (remainder 206 40)))

(gcd 40 (remainder 206 40)))

(gcd 40 6)

(if (= 6 0)
    40
    (gcd 6 (remainder 40 6))))

(gcd 6 (remainder 40 6)))
...
#+END_SRC

Obviously, that each time the =gcd= only evaluate the =remainder= once, so there are just 4 times.
* Ex 1.21
| number | smallest dividor |
|--------+------------------|
| 199    | 199              |
| 1999   | 1999             |
| 19999  | 7                |

* Ex 1.22
At first, I set the =count= to be 3. So I intend to find three consecutive prime numbers. The results are weird:

| number | time (ms) |
|--------+-----------|
|   1000 |         0 |
|  10000 |         0 |
| 100000 |         2 |

The time does not bear out the rules for the number. I guess it is becauese the relative error rate of the time function is too large. So I change =count= to 30 and try to start with 100000:

|   number | time (ms) | ratio |
|----------+-----------+-------|
|   100000 |        10 |       |
|  1000000 |        24 |  2.4  |
| 10000000 |        80 |  3.3  |

The expected ratio between these every two consecutive numbers should be 3.15. But it seems that:

1. For larger numbers the 30th prime number might be even further than the smaller number. As prime number follows a average of 1 / \ln(n). So the ratio should become larger.

* Ex 1.23
I have implement the function as followed:
#+BEGIN_SRC scheme
;another version of the smallest dividor
(define (smallest-dividor-two n)
  ;Next function to skip even number
  (define (next n)
    (if (= n 2)
        3
        (+ n 2)))
  (define (sm-i k)
    (cond ((> (square k) n) n)
          ((divides? n k) k)
          (else (sm-i (next k)))))
  (sm-i 2))

(define (test-find-prime num func)
  ;test for the prime number
  (define (tf n)
    (= (func n) n))

 ;denote the start time
  (define start (current-milliseconds))

 ;iteratively go up to num
  (define (time k)
    (cond ((= k num) (rt (current-milliseconds)))
          ((tf k) (dpg k))
          (else
           (time (+ k 1)))))

  ;display and go to next level
  (define (dpg k)
;    (display k)
;    (display "\t")
    (time (+ k 1)))

 ;report the answer
  (define (rt end)
    (newline)
    (display "With ")
    (display (- end start))
    (display " ms , found prime number ")
    (display " out of ")
    (display num)
    (newline))

  (time 2))
#+END_SRC

So I takes the num to be 100000, the results are:
| function name        | time (ms) |
|----------------------+-----------|
| smallest-dividor     |      1766 |
| smallest-dividor-two |      1442 |

The reason for which the time is not exactly the twice is that:

1. The timing function has a large error rate.

2. The timing does not only contains the time the machine ran the two functions but also involves going into loops and print.

* Ex 1.24
I can not find a very solid =runtime= primitive here.I am using the =chicken= so I used the primitive =current-milliseconds=.So the results are:

|  number | time (ms) |
|---------+-----------|
|    1000 |         8 |
| 1000000 |        15 |

And as \log(100000) / \log(1000) is 2.00, this is not quite accurate, the reason lies:
1. The function is not reliable. It has a large error rate.
2. The processes contains also going into loops and print, thus the ratio should not equal to 2
* Ex 1.25
They are both correct. But the new one will definitely run much more time than the other, for it calculate all the exponienial numbers.
* Ex 1.26
By doing this, the =expmod= got computed twice when trying to reduce the calculation. So it is really only \Theta(n), not \Theta(\log n).
* Ex 1.27
For this numbers:
: 561, 1105, 1729, 2465, 2821, and 6601
=smallest-dividor= gives:
: 3 5 7 5 7 and 7
But they passed the Fermat Test.

* Ex 1.28
Understand the program but do not understand how to implement it with single control flow.
