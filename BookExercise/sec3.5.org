* Exercise 3.50
Complete the following definition, which generalizes stream-map to allow procedures that take multiple arguments, analogous to map in section 2.2.3, footnote 12.
** Answer
#+BEGIN_SRC scheme
(define (stream-map proc . argstreams)
  (if (stream-null? (car argstreams))
      the-empty-stream
      (cons
       (apply proc (map (lambda (s) (stream-car s)) argstreams))
       (memo-proc (lambda ()
                    (apply stream-map
                           (cons proc (map (lambda (s) (stream-cdr s))
                                         argstreams))))))))
#+END_SRC
* Exercise 3.51
In order to take a closer look at delayed evaluation, we will use the following procedure, which simply returns its argument after printing it:
#+BEGIN_SRC scheme
(define (show x)
  (display-line x)
  x)
#+END_SRC
What does the interpreter print in response to evaluating each expression in the following sequence?
#+BEGIN_SRC scheme
(define x (stream-map show (stream-enumerate-interval 0 10)))
(stream-ref x 5)
(stream-ref x 7)
#+END_SRC

** Answer
#+BEGIN_EXAMPLE
0
(0 . #<procedure (?)>)
---
1
2
3
4
---
5
6
#+END_EXAMPLE

* Exercise 3.52
Consider the sequence of expressions
#+BEGIN_SRC scheme
(define sum 0)
(define (accum x)
  (set! sum (+ x sum))
  sum)
(define seq (stream-map accum (stream-enumerate-interval 1 20)))
(define y (stream-filter even? seq))
(define z (stream-filter (lambda (x) (= (remainder x 5) 0))
seq))
(stream-ref y 7)
(display-stream z)
#+END_SRC
What is the value of sum after each of the above expressions is evaluated? What is the printed response to evaluating the stream-ref and display-stream expressions? Would these responses differ if we had implemented (delay <exp>) simply as (lambda () <exp>) without using the optimization provided by memo-proc ? Explain.

** Answer
#+BEGIN_EXAMPLE
0
---
#<procedure (accum)>
---
(1 . #<procedure (?)>)
---
(6 . #<procedure (?)>)
---
(10 . #<procedure (?)>)
---
(66 . #<procedure (?)>)
---
136
---
(10 15 45 55 105 120 190 210)
#+END_EXAMPLE
* Exercise 3.53
Without running the program, describe the elements of the stream defined by
#+BEGIN_SRC scheme
(define s (cons-stream 1 (add-streams s s)))
#+END_SRC
** Answers
Geometric series of 2^{n} (n=0,1,2,...)
* Exercise 3.54
Define a procedure mul-streams, analogous to add-streams, that produces the elementwise product of its two input streams. Use this together with the stream of integers to complete the following definition of the stream whose nth element (counting from 0) is n + 1 factorial:
#+BEGIN_SRC scheme
(define factorials (cons-stream 1 (mul-streams <??> <??>)))
#+END_SRC

** Answer
#+BEGIN_SRC scheme
(define factorials (cons 1 (memo-proc (lambda ()
                                        (stream-multiply (intsinitwith 2)
                                                         factorials)))))
#+END_SRC

* Exercise 3.55
Define a procedure partial-sums that takes as argument a stream S and returns the stream whose elements are S0, S0 + S1, S0 + S1 + S2, .... For example, (partial-sums integers) should be the stream 1, 3, 6, 10, 15, ....
** Answer
#+BEGIN_SRC scheme
(define partial-sums (cons 0 (memo-proc (lambda ()
                                          (stream-plus (intsinitwith 1)
                                                       partial-sums)))))
#+END_SRC

* Exercise 3.56
A famous problem, first raised by R. Hamming, is to enumerate, in ascending order with no repetitions, all positive integers with no prime factors other than 2, 3, or 5. One obvious way to do this is to simply test each integer in turn to see whether it has any factors other than 2, 3, and 5. But this is very inefficient, since, as the integers get larger, fewer and fewer of them fit the requirement. As an alternative, let us call the required stream of numbers S and notice the following facts about it.
1. S begins with 1.
2. The elements of (scale-stream S 2) are also elements of S.
3. The same is true for (scale-stream S 3) and (scale-stream 5 S).
4. These are all the elements of S.
Now all we have to do is combine elements from these sources. For this we define a procedure merge that combines two ordered streams into one ordered result stream, eliminating repetitions:
#+BEGIN_SRC scheme
(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
        ￼￼(let ((s1car (stream-car s1))
                (s2car (stream-car s2)))
            (cond ((< s1car s2car)
                   (cons-stream s1car (merge (stream-cdr s1) s2)))
                  ((> s1car s2car)
                   (cons-stream s2car (merge s1 (stream-cdr s2))))
                  (else
                   (cons-stream s1car
                                (merge (stream-cdr s1)
                                       (stream-cdr s2)))))))))
#+END_SRC
Then the required stream may be constructed with merge, as follows:
#+BEGIN_SRC scheme
(define S (cons-stream 1 (merge <??> <??>)))
#+END_SRC
Fill in the missing expressions in the places marked <??> above.
** Answer
*** Original Methods
#+BEGIN_SRC scheme
(define S (cons 1 (memo-proc (lambda ()
                               (merge (stream-scale S 2)
                                      (merge (stream-scale S 3)
                                             (stream-scale S 5)))))))
#+END_SRC
*** Make different merge
The text gives only merge between two streams, let's expand it to multiple first.
#+BEGIN_SRC scheme
(define (stream-merge order same? . streams)
  ;; (write "all streams:")
  ;; (print streams)
  (cond ((null? streams) the-empty-stream)
        ((let* ((non-null-streams (filter (lambda (s) (not (stream-null? s)))
                                          streams))
                ;; (tmp (begin (write "non-null-streams:")
                ;;             (print non-null-streams)))
                (chosen-element (apply order (map stream-car non-null-streams))))
           ;; (write "chosen element:")
           ;; (print chosen-element)
           ;; (print "ok")
           (cons chosen-element (memo-proc (lambda ()
                                             (let ((rest-streams (foundmap (lambda (s) (same? chosen-element (stream-car s)))
                                                                           cons stream-cdr the-empty-stream non-null-streams)))
                                               (apply stream-merge (cons order (cons same? rest-streams)))))))))))
#+END_SRC

But this merge does not remove the redundant elements. So construct a remove redundant operator.
#+BEGIN_SRC scheme
(define (stream-remove-redundant stream same?)
  (cons (stream-car stream)
        (memo-proc (lambda ()
                     (stream-remove-redundant (stream-filter (lambda (n) (not (same? n (stream-car stream))))
                                                             (stream-cdr stream))
                                              same?)))))
#+END_SRC

So the result is simply:
#+BEGIN_SRC scheme
(define s (stream-remove-redundant (cons 1 (memo-proc (lambda ()
                                                        (stream-merge min
                                                                      =
                                                                      (stream-scale s 2)
                                                                      (stream-scale s 3)
                                                                      (stream-scale s 5)))))
                                   =))
#+END_SRC
